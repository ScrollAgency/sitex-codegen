/* eslint-disable */
/* tslint:disable */
// @ts-nocheck
/* prettier-ignore-start */

/** @jsxRuntime classic */
/** @jsx createPlasmicElementProxy */
/** @jsxFrag React.Fragment */

// This class is auto-generated by Plasmic; please do not edit!
// Plasmic Project: 341WB3S6fAjbZggAzyKhr1
// Component: eOKvLoQY8qlH

import * as React from "react";

import Head from "next/head";
import Link, { LinkProps } from "next/link";
import { useRouter } from "next/router";

import {
  Flex as Flex__,
  MultiChoiceArg,
  PlasmicDataSourceContextProvider as PlasmicDataSourceContextProvider__,
  PlasmicIcon as PlasmicIcon__,
  PlasmicImg as PlasmicImg__,
  PlasmicLink as PlasmicLink__,
  PlasmicPageGuard as PlasmicPageGuard__,
  SingleBooleanChoiceArg,
  SingleChoiceArg,
  Stack as Stack__,
  StrictProps,
  Trans as Trans__,
  classNames,
  createPlasmicElementProxy,
  deriveRenderOpts,
  ensureGlobalVariants,
  generateOnMutateForSpec,
  generateStateOnChangeProp,
  generateStateOnChangePropForCodeComponents,
  generateStateValueProp,
  get as $stateGet,
  hasVariant,
  initializeCodeComponentStates,
  initializePlasmicStates,
  makeFragment,
  omit,
  pick,
  renderPlasmicSlot,
  set as $stateSet,
  useCurrentUser,
  useDollarState,
  usePlasmicTranslator,
  useTrigger,
  wrapWithClassName
} from "@plasmicapp/react-web";
import {
  DataCtxReader as DataCtxReader__,
  useDataEnv,
  useGlobalActions
} from "@plasmicapp/react-web/lib/host";

import { TabUnderline } from "@plasmicpkgs/plasmic-tabs";
import Button from "../../Button"; // plasmic-import: lcnlii-Mi9bF/component

import "@plasmicapp/react-web/lib/plasmic.css";

import plasmic_antd_5_hostless_css from "../antd_5_hostless/plasmic.module.css"; // plasmic-import: ohDidvG9XsCeFumugENU3J/projectcss
import projectcss from "./plasmic.module.css"; // plasmic-import: 341WB3S6fAjbZggAzyKhr1/projectcss
import sty from "./PlasmicRetexMenu.module.css"; // plasmic-import: eOKvLoQY8qlH/css

import CircleIcon from "./icons/PlasmicIcon__Circle"; // plasmic-import: GXxwbmvNEgwq/icon
import ChevronDownIcon from "./icons/PlasmicIcon__ChevronDown"; // plasmic-import: t_DMhjzzg7u-/icon

createPlasmicElementProxy;

export type PlasmicRetexMenu__VariantMembers = {};
export type PlasmicRetexMenu__VariantsArgs = {};
type VariantPropType = keyof PlasmicRetexMenu__VariantsArgs;
export const PlasmicRetexMenu__VariantProps = new Array<VariantPropType>();

export type PlasmicRetexMenu__ArgsType = { submenu?: string };
type ArgPropType = keyof PlasmicRetexMenu__ArgsType;
export const PlasmicRetexMenu__ArgProps = new Array<ArgPropType>("submenu");

export type PlasmicRetexMenu__OverridesType = {
  retexMenu?: Flex__<"div">;
  tabUnderline?: Flex__<typeof TabUnderline>;
  generalButtonGroup?: Flex__<"div">;
  tabActive3?: Flex__<"div">;
  operationButtonGroup?: Flex__<"div">;
  tabActive4?: Flex__<"div">;
  anayticsButtonGroup?: Flex__<"div">;
  tabActive?: Flex__<"div">;
  syntheseButtonGroup?: Flex__<"div">;
  tabActive2?: Flex__<"div">;
};

export interface DefaultRetexMenuProps {
  submenu?: string;
  className?: string;
}

const $$ = {};

function useNextRouter() {
  try {
    return useRouter();
  } catch {}
  return undefined;
}

function PlasmicRetexMenu__RenderFunc(props: {
  variants: PlasmicRetexMenu__VariantsArgs;
  args: PlasmicRetexMenu__ArgsType;
  overrides: PlasmicRetexMenu__OverridesType;
  forNode?: string;
}) {
  const { variants, overrides, forNode } = props;

  const args = React.useMemo(
    () =>
      Object.assign(
        {},
        Object.fromEntries(
          Object.entries(props.args).filter(([_, v]) => v !== undefined)
        )
      ),
    [props.args]
  );

  const $props = {
    ...args,
    ...variants
  };

  const __nextRouter = useNextRouter();

  const $ctx = useDataEnv?.() || {};
  const refsRef = React.useRef({});
  const $refs = refsRef.current;

  return (
    <div
      data-plasmic-name={"retexMenu"}
      data-plasmic-override={overrides.retexMenu}
      data-plasmic-root={true}
      data-plasmic-for-node={forNode}
      className={classNames(
        projectcss.all,
        projectcss.root_reset,
        projectcss.plasmic_default_styles,
        projectcss.plasmic_mixins,
        projectcss.plasmic_tokens,
        plasmic_antd_5_hostless_css.plasmic_tokens,
        sty.retexMenu
      )}
    >
      <TabUnderline
        data-plasmic-name={"tabUnderline"}
        data-plasmic-override={overrides.tabUnderline}
        className={classNames("__wab_instance", sty.tabUnderline)}
      />

      <div
        data-plasmic-name={"generalButtonGroup"}
        data-plasmic-override={overrides.generalButtonGroup}
        className={classNames(projectcss.all, sty.generalButtonGroup)}
      >
        <Button
          className={classNames("__wab_instance", sty.button___3Nc8R)}
          label={
            <div
              className={classNames(
                projectcss.all,
                projectcss.__wab_text,
                sty.text__gf834
              )}
            >
              {"G\u00e9n\u00e9ral"}
            </div>
          }
          onClick={async event => {
            const $steps = {};

            $steps["goToBilanGeneral"] = true
              ? (() => {
                  const actionArgs = { destination: `/bilan_retex_general` };
                  return (({ destination }) => {
                    if (
                      typeof destination === "string" &&
                      destination.startsWith("#")
                    ) {
                      document
                        .getElementById(destination.substr(1))
                        .scrollIntoView({ behavior: "smooth" });
                    } else {
                      __nextRouter?.push(destination);
                    }
                  })?.apply(null, [actionArgs]);
                })()
              : undefined;
            if (
              $steps["goToBilanGeneral"] != null &&
              typeof $steps["goToBilanGeneral"] === "object" &&
              typeof $steps["goToBilanGeneral"].then === "function"
            ) {
              $steps["goToBilanGeneral"] = await $steps["goToBilanGeneral"];
            }
          }}
          type={"tag"}
        />

        {(() => {
          try {
            return $props.submenu === "general";
          } catch (e) {
            if (
              e instanceof TypeError ||
              e?.plasmicType === "PlasmicUndefinedDataError"
            ) {
              return true;
            }
            throw e;
          }
        })() ? (
          <div
            data-plasmic-name={"tabActive3"}
            data-plasmic-override={overrides.tabActive3}
            className={classNames(projectcss.all, sty.tabActive3)}
          />
        ) : null}
      </div>
      <div
        data-plasmic-name={"operationButtonGroup"}
        data-plasmic-override={overrides.operationButtonGroup}
        className={classNames(projectcss.all, sty.operationButtonGroup)}
      >
        <Button
          className={classNames("__wab_instance", sty.button__art3P)}
          label={
            <div
              className={classNames(
                projectcss.all,
                projectcss.__wab_text,
                sty.text__g4IJa
              )}
            >
              {"Op\u00e9rations"}
            </div>
          }
          onClick={async event => {
            const $steps = {};

            $steps["goToBilanOperations"] = true
              ? (() => {
                  const actionArgs = { destination: `/bilan_retex_operations` };
                  return (({ destination }) => {
                    if (
                      typeof destination === "string" &&
                      destination.startsWith("#")
                    ) {
                      document
                        .getElementById(destination.substr(1))
                        .scrollIntoView({ behavior: "smooth" });
                    } else {
                      __nextRouter?.push(destination);
                    }
                  })?.apply(null, [actionArgs]);
                })()
              : undefined;
            if (
              $steps["goToBilanOperations"] != null &&
              typeof $steps["goToBilanOperations"] === "object" &&
              typeof $steps["goToBilanOperations"].then === "function"
            ) {
              $steps["goToBilanOperations"] = await $steps[
                "goToBilanOperations"
              ];
            }
          }}
          type={"tag"}
        />

        {(() => {
          try {
            return $props.submenu === "operations";
          } catch (e) {
            if (
              e instanceof TypeError ||
              e?.plasmicType === "PlasmicUndefinedDataError"
            ) {
              return true;
            }
            throw e;
          }
        })() ? (
          <div
            data-plasmic-name={"tabActive4"}
            data-plasmic-override={overrides.tabActive4}
            className={classNames(projectcss.all, sty.tabActive4)}
          />
        ) : null}
      </div>
      <div
        data-plasmic-name={"anayticsButtonGroup"}
        data-plasmic-override={overrides.anayticsButtonGroup}
        className={classNames(projectcss.all, sty.anayticsButtonGroup)}
      >
        <Button
          className={classNames("__wab_instance", sty.button__fpDlc)}
          label={
            <div
              className={classNames(
                projectcss.all,
                projectcss.__wab_text,
                sty.text__ak69D
              )}
            >
              {"Analytics"}
            </div>
          }
          onClick={async event => {
            const $steps = {};

            $steps["goToBilanAnalytics"] = true
              ? (() => {
                  const actionArgs = { destination: `/bilan_retex_analytics` };
                  return (({ destination }) => {
                    if (
                      typeof destination === "string" &&
                      destination.startsWith("#")
                    ) {
                      document
                        .getElementById(destination.substr(1))
                        .scrollIntoView({ behavior: "smooth" });
                    } else {
                      __nextRouter?.push(destination);
                    }
                  })?.apply(null, [actionArgs]);
                })()
              : undefined;
            if (
              $steps["goToBilanAnalytics"] != null &&
              typeof $steps["goToBilanAnalytics"] === "object" &&
              typeof $steps["goToBilanAnalytics"].then === "function"
            ) {
              $steps["goToBilanAnalytics"] = await $steps["goToBilanAnalytics"];
            }
          }}
          type={"tag"}
        />

        {(() => {
          try {
            return $props.submenu === "analytics";
          } catch (e) {
            if (
              e instanceof TypeError ||
              e?.plasmicType === "PlasmicUndefinedDataError"
            ) {
              return true;
            }
            throw e;
          }
        })() ? (
          <div
            data-plasmic-name={"tabActive"}
            data-plasmic-override={overrides.tabActive}
            className={classNames(projectcss.all, sty.tabActive)}
          />
        ) : null}
      </div>
      <div
        data-plasmic-name={"syntheseButtonGroup"}
        data-plasmic-override={overrides.syntheseButtonGroup}
        className={classNames(projectcss.all, sty.syntheseButtonGroup)}
      >
        <Button
          className={classNames("__wab_instance", sty.button__c35A8)}
          label={
            <div
              className={classNames(
                projectcss.all,
                projectcss.__wab_text,
                sty.text___1ELzY
              )}
            >
              {"Synth\u00e8se"}
            </div>
          }
          onClick={async event => {
            const $steps = {};

            $steps["goToBilanSynthese"] = true
              ? (() => {
                  const actionArgs = { destination: `/bilan_retex_synthese` };
                  return (({ destination }) => {
                    if (
                      typeof destination === "string" &&
                      destination.startsWith("#")
                    ) {
                      document
                        .getElementById(destination.substr(1))
                        .scrollIntoView({ behavior: "smooth" });
                    } else {
                      __nextRouter?.push(destination);
                    }
                  })?.apply(null, [actionArgs]);
                })()
              : undefined;
            if (
              $steps["goToBilanSynthese"] != null &&
              typeof $steps["goToBilanSynthese"] === "object" &&
              typeof $steps["goToBilanSynthese"].then === "function"
            ) {
              $steps["goToBilanSynthese"] = await $steps["goToBilanSynthese"];
            }
          }}
          type={"tag"}
        />

        {(() => {
          try {
            return $props.submenu === "synthese";
          } catch (e) {
            if (
              e instanceof TypeError ||
              e?.plasmicType === "PlasmicUndefinedDataError"
            ) {
              return true;
            }
            throw e;
          }
        })() ? (
          <div
            data-plasmic-name={"tabActive2"}
            data-plasmic-override={overrides.tabActive2}
            className={classNames(projectcss.all, sty.tabActive2)}
          />
        ) : null}
      </div>
    </div>
  ) as React.ReactElement | null;
}

const PlasmicDescendants = {
  retexMenu: [
    "retexMenu",
    "tabUnderline",
    "generalButtonGroup",
    "tabActive3",
    "operationButtonGroup",
    "tabActive4",
    "anayticsButtonGroup",
    "tabActive",
    "syntheseButtonGroup",
    "tabActive2"
  ],
  tabUnderline: ["tabUnderline"],
  generalButtonGroup: ["generalButtonGroup", "tabActive3"],
  tabActive3: ["tabActive3"],
  operationButtonGroup: ["operationButtonGroup", "tabActive4"],
  tabActive4: ["tabActive4"],
  anayticsButtonGroup: ["anayticsButtonGroup", "tabActive"],
  tabActive: ["tabActive"],
  syntheseButtonGroup: ["syntheseButtonGroup", "tabActive2"],
  tabActive2: ["tabActive2"]
} as const;
type NodeNameType = keyof typeof PlasmicDescendants;
type DescendantsType<T extends NodeNameType> =
  (typeof PlasmicDescendants)[T][number];
type NodeDefaultElementType = {
  retexMenu: "div";
  tabUnderline: typeof TabUnderline;
  generalButtonGroup: "div";
  tabActive3: "div";
  operationButtonGroup: "div";
  tabActive4: "div";
  anayticsButtonGroup: "div";
  tabActive: "div";
  syntheseButtonGroup: "div";
  tabActive2: "div";
};

type ReservedPropsType = "variants" | "args" | "overrides";
type NodeOverridesType<T extends NodeNameType> = Pick<
  PlasmicRetexMenu__OverridesType,
  DescendantsType<T>
>;
type NodeComponentProps<T extends NodeNameType> =
  // Explicitly specify variants, args, and overrides as objects
  {
    variants?: PlasmicRetexMenu__VariantsArgs;
    args?: PlasmicRetexMenu__ArgsType;
    overrides?: NodeOverridesType<T>;
  } & Omit<PlasmicRetexMenu__VariantsArgs, ReservedPropsType> & // Specify variants directly as props
    // Specify args directly as props
    Omit<PlasmicRetexMenu__ArgsType, ReservedPropsType> &
    // Specify overrides for each element directly as props
    Omit<
      NodeOverridesType<T>,
      ReservedPropsType | VariantPropType | ArgPropType
    > &
    // Specify props for the root element
    Omit<
      Partial<React.ComponentProps<NodeDefaultElementType[T]>>,
      ReservedPropsType | VariantPropType | ArgPropType | DescendantsType<T>
    >;

function makeNodeComponent<NodeName extends NodeNameType>(nodeName: NodeName) {
  type PropsType = NodeComponentProps<NodeName> & { key?: React.Key };
  const func = function <T extends PropsType>(
    props: T & StrictProps<T, PropsType>
  ) {
    const { variants, args, overrides } = React.useMemo(
      () =>
        deriveRenderOpts(props, {
          name: nodeName,
          descendantNames: PlasmicDescendants[nodeName],
          internalArgPropNames: PlasmicRetexMenu__ArgProps,
          internalVariantPropNames: PlasmicRetexMenu__VariantProps
        }),
      [props, nodeName]
    );
    return PlasmicRetexMenu__RenderFunc({
      variants,
      args,
      overrides,
      forNode: nodeName
    });
  };
  if (nodeName === "retexMenu") {
    func.displayName = "PlasmicRetexMenu";
  } else {
    func.displayName = `PlasmicRetexMenu.${nodeName}`;
  }
  return func;
}

export const PlasmicRetexMenu = Object.assign(
  // Top-level PlasmicRetexMenu renders the root element
  makeNodeComponent("retexMenu"),
  {
    // Helper components rendering sub-elements
    tabUnderline: makeNodeComponent("tabUnderline"),
    generalButtonGroup: makeNodeComponent("generalButtonGroup"),
    tabActive3: makeNodeComponent("tabActive3"),
    operationButtonGroup: makeNodeComponent("operationButtonGroup"),
    tabActive4: makeNodeComponent("tabActive4"),
    anayticsButtonGroup: makeNodeComponent("anayticsButtonGroup"),
    tabActive: makeNodeComponent("tabActive"),
    syntheseButtonGroup: makeNodeComponent("syntheseButtonGroup"),
    tabActive2: makeNodeComponent("tabActive2"),

    // Metadata about props expected for PlasmicRetexMenu
    internalVariantProps: PlasmicRetexMenu__VariantProps,
    internalArgProps: PlasmicRetexMenu__ArgProps
  }
);

export default PlasmicRetexMenu;
/* prettier-ignore-end */
